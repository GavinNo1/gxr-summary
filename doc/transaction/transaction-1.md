mysql事务隔离级别以及实现原理

ru rc rr ss四种隔离级别

事务的隔离级别其实都是对于读数据的定义

rc实现方式为：

    更新的时候加锁，其他事务任何读都要等待。
    使用mvcc 快照读 每次读都生成新的快照和 read view
解决问题以及存在的问题：

    可以解决脏读 无法解决不可重复读  不可重复读的重点是修改:
    同样的条件的select, 你读取过的数据, 再次读取出来发现值不一样了
    例子：A事务结算时，查询金额足够刚好500，去结算流程，此时B事务刚好减去金额200，A事务在结算最后扣除金额时发现不够
rc隔离级别下如何解决不可重复读：加锁 

    情况一：加锁+唯一索引或者主键索引 可以解决不可重复读，由于是唯一索引或者是主键索引 数据是独一份，也就不存在幻读的情况。
    情况二：加锁+ 非唯一索引或者没有索引，由于gap锁的引进，既可以解决不可重复读，也可解决幻读的场景
    情况三：如果使用mvcc方式实现的rc，由于mvcc每次读都生成新的快照和 read view，无法解决不可重复读问题。

rr实现方式：

    读的时候加锁，其他事务等待。
    使用mvcc 快照读 每次读都使用第一次读生成的快照读和read view
rr解决的问题以及存在的问题
    
    可以解决不可重复读，不能解决幻读。幻读的重点在于新增或者删除:
    同样的条件的select, 第1次和第2次读出来的记录数不一样例子：A事务插入一条name='xiao’的记录，判断不存在，继续下面的逻辑；
    此时B事务插入一条name="xiao"的记录并提交，A事务就报错了

rr隔离级别下如何解决幻读：

     情况一：加锁+唯一索引或者主键索引，由于是唯一索引或者是主键索引 数据是独一份，也就不存在幻读的情况。
     情况二：加锁+ 非唯一索引或者没有索引，由于gap锁的引进，数据在锁定范围为不被允许插入或者删除 也就不存在幻读的情况。
     情况三：使用mvcc 每次读都是根据第一次读生成的快照和read view 那么每次读的数据都一致，则不存在幻读。
     
 说明：innodb只对读无锁，所以mysql实现隔离级别时使用mvcc 保证读无锁化，即保证读非阻塞，写操作仍是上锁的悲观并发控制。
 在rc级别下保证读不阻塞只不过读取到的数据可能不是最新的 写时加锁。在rc级别下保证读不阻塞，读到的数据也不是最新的，写时加锁。
 使用mvcc+锁的形式实现。
 
 参考链接：
    
    https://www.cnblogs.com/mysql-hang/articles/11027685.html
    https://www.jianshu.com/p/dab1c0ecbac0
    https://www.cnblogs.com/shujiying/p/11347632.html
    https://blog.csdn.net/SnailMann/article/details/94724197
     
    